<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <!-- three.js library -->
    <script src="/js/three.js/three.min.js"></script>
    <script src="/js/three.js/loaders/GLTFLoader.js"></script>
    <!-- ar.js -->
    <script src="/js/ar.js/ar.js"></script>
    <script>
      THREEx.ArToolkitContext.baseURL = "../";
    </script>
    <title>Magic Cube</title>
  </head>
  <body style="margin: 0px; overflow: hidden;">
    <script>
      //////////////////////////////////////////////////////////////////////////////////
      //		Init
      //////////////////////////////////////////////////////////////////////////////////

      // init renderer
      let renderer = new THREE.WebGLRenderer({
        antialias: false,
        alpha: true,
      });
      renderer.setClearColor(new THREE.Color("lightgrey"), 0);
      // renderer.setPixelRatio(1 / 2);
      renderer.setSize(640, 480);
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.top = "0px";
      renderer.domElement.style.left = "0px";

      //material color correction
      renderer.shadowMap.enabled = true;
      renderer.outputEncoding = THREE.sRGBEncoding;

      document.body.appendChild(renderer.domElement);

      // array of functions for the rendering loop
      let onRenderFcts = [];

      // init scene and camera
      let scene = new THREE.Scene();

      //////////////////////////////////////////////////////////////////////////////////
      //		Initialize a basic camera
      //////////////////////////////////////////////////////////////////////////////////

      // Create a camera
      let camera = new THREE.Camera();
      scene.add(camera);

      ////////////////////////////////////////////////////////////////////////////////
      //          handle arToolkitSource
      ////////////////////////////////////////////////////////////////////////////////

      let arToolkitSource = new THREEx.ArToolkitSource({
        // type of source - ['webcam', 'image', 'video']
        sourceType: "webcam",
        // // resolution of at which we initialize the source image
        sourceWidth: 960,
        sourceHeight: 720,
        // // resolution displayed for the source
        displayWidth: 960,
        displayHeight: 720,
      });

      arToolkitSource.init(function onReady() {
        setTimeout(() => {
          onResize();
        }, 250);
      });

      // handle resize
      window.addEventListener("resize", function () {
        onResize();
      });

      function onResize() {
        arToolkitSource.onResizeElement();
        arToolkitSource.copyElementSizeTo(renderer.domElement);
        if (arToolkitContext.arController !== null) {
          arToolkitSource.copyElementSizeTo(
            arToolkitContext.arController.canvas
          );
        }
      }
      ////////////////////////////////////////////////////////////////////////////////
      //          initialize arToolkitContext
      ////////////////////////////////////////////////////////////////////////////////

      // create atToolkitContext
      let arToolkitContext = new THREEx.ArToolkitContext({
        // debug - true if one should display artoolkit debug canvas, false otherwise
        debug: false,

        // the mode of detection - ['color', 'color_and_matrix', 'mono', 'mono_and_matrix']
        detectionMode: "mono",
        // Pattern ratio for custom markers
        patternRatio: 0.8,
        // url of the camera parameters
        cameraParametersUrl:
          THREEx.ArToolkitContext.baseURL + "../data/data/camera_para.dat",

        maxDetectionRate: 60,

        // resolution of at which we detect pose in the source image
        // canvasWidth: 240,
        // canvasHeight: 180,

        // enable image smoothing or not for canvas copy - default to true
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
        imageSmoothingEnabled: true,
      });

      // initialize it
      arToolkitContext.init(function onCompleted() {
        // copy projection matrix to camera
        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
      });

      // update artoolkit on every frame
      onRenderFcts.push(function () {
        if (arToolkitSource.ready === false) return;
        arToolkitContext.update(arToolkitSource.domElement);
      });

      ////////////////////////////////////////////////////////////
      // setup markerRoots
      ////////////////////////////////////////////////////////////

      let markerRootArray = [];
      let markerGroupArray = [];
      let patternArray = ["Top", "Right", "Down", "Left", "Front", "Back"];

      let p = 1.5;
      let positionScene = [
        new THREE.Vector3(0, -p / 2, 0),
        new THREE.Vector3(-p / 2, 0, 0),
        new THREE.Vector3(0, p / 2, 0),
        new THREE.Vector3(p / 2, 0, 0),
        new THREE.Vector3(0, 0, -p / 2),
        new THREE.Vector3(0, 0, p / 2),
      ];

      let rotationArray = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(
          THREE.Math.degToRad(-90),
          THREE.Math.degToRad(-90),
          0
        ),
        new THREE.Vector3(THREE.Math.degToRad(-180), 0, 0),
        new THREE.Vector3(THREE.Math.degToRad(-90), THREE.Math.degToRad(90), 0),
        new THREE.Vector3(THREE.Math.degToRad(-90), 0, 0),
        new THREE.Vector3(
          THREE.Math.degToRad(-90),
          THREE.Math.degToRad(180),
          0
        ),
      ];

      for (let i = 0; i < 6; i++) {
        let markerRoot = new THREE.Group();
        markerRootArray.push(markerRoot);
        scene.add(markerRoot);
        let markerControls = new THREEx.ArMarkerControls(
          arToolkitContext,
          markerRoot,
          {
            size: 1,
            type: "pattern",
            patternUrl: "../magic-cube/data/" + patternArray[i] + ".patt",
            // changeMatrixMode: "cameraTransformMatrix",
          }
        );

        let markerGroup = new THREE.Group();
        markerGroupArray.push(markerGroup);
        markerGroup.rotation.setFromVector3(rotationArray[i]);

        markerRoot.add(markerGroup);
      }

      // build a smoothedControls
      let smoothedRoot = new THREE.Group();
      scene.add(smoothedRoot);
      let smoothedControls = new THREEx.ArSmoothedControls(smoothedRoot, {
        lerpPosition: 0.4,
        lerpQuaternion: 0.3,
        lerpScale: 1,
      });
      // onRenderFcts.push(function (delta) {
      //   smoothedControls.update(markerRoot);
      // });

      //////////////////////////////////////////////////////////////////////////////////
      //    add an object in the scene
      //////////////////////////////////////////////////////////////////////////////////

      let sceneGroup = new THREE.Group();
      let mixer;
      //add object 3d
      let loaderGLTF = new THREE.GLTFLoader();
      // Load a glTF resource
      loaderGLTF.load(
        // resource URL
        "./resources/MagicCube.glb",
        // called when the resource is loaded
        function (gltf) {
          gltf.scene.traverse((o) => {
            if (o.isMesh) {
              // console.log(o.name);
              if (o.name === "CuboInterno") {
                o.material.side = THREE.FrontSide;
                o.receiveShadow = true;
              } else {
                o.castShadow = true;
                if (o.name !== "Marco") {
                  // o.castShadow = true;
                  o.receiveShadow = true;
                }
              }
            }
          });

          mixer = new THREE.AnimationMixer(gltf.scene);
          let action = mixer.clipAction(gltf.animations[0]);
          action.setLoop(THREE.LoopRepeat);
          action.play();

          scene.add(gltf.scene);
          let size = 1.5;
          gltf.scene.scale.set(p, p, p);
          sceneGroup.add(gltf.scene);
        },
        // called while loading is progressing
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        // called when loading has errors
        function (error) {
          console.log("An error happened");
        }
      );

      // Lights
      let ambientLight = new THREE.AmbientLight(0xc7c2bf, 0.5);
      let spotlight = new THREE.SpotLight(0xffa95c, 0.5);
      spotlight.castShadow = true;
      spotlight.position.set(0, 1.5, 0.3);
      // spotlight.shadow.bias = 0.0001;
      // spotlight.shadow.mapSize.width = 1024;
      // spotlight.shadow.mapSize.height = 1024;
      camera.add(ambientLight, spotlight);

      //
      onRenderFcts.push(function (delta) {
        // update artoolkit on every frame
        if (arToolkitSource.ready !== false)
          arToolkitContext.update(arToolkitSource.domElement);

        for (let i = 0; i < 6; i++) {
          if (markerRootArray[i].visible) {
            sceneGroup.position.copy(positionScene[i]);
            markerGroupArray[i].add(sceneGroup);
            // smoothedControls.update(markerGroupArray[i]); //
            // console.log("visible: " + patternArray[i]);
            if (mixer) {
              mixer.update(delta);
            }
            break;
          }
        }
      });

      //////////////////////////////////////////////////////////////////////////////////
      //		render the whole thing on the page
      //////////////////////////////////////////////////////////////////////////////////

      // render the scene
      onRenderFcts.push(function () {
        renderer.render(scene, camera);
      });

      // run the rendering loop
      let lastTimeMsec = null;
      requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        let deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        onRenderFcts.forEach(function (onRenderFct) {
          onRenderFct(deltaMsec / 1000, nowMsec / 1000);
        });
      });
    </script>
  </body>
</html>
