<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <!-- three.js library -->
    <script src="/js/three.js/three.min.js"></script>
    <!-- ar.js -->
    <script src="/js/ar.js/ar.js"></script>
    <script>
      THREEx.ArToolkitContext.baseURL = "../";
    </script>
    <title>Marker Tracking AR.js (template)</title>
  </head>
  <body style="margin: 0px; overflow: hidden;">
    <script>
      //////////////////////////////////////////////////////////////////////////////////
      //		Init
      //////////////////////////////////////////////////////////////////////////////////

      // init renderer
      let renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setClearColor(new THREE.Color("lightgrey"), 0);
      renderer.setSize(640, 480);
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.top = "0px";
      renderer.domElement.style.left = "0px";
      document.body.appendChild(renderer.domElement);

      // array of functions for the rendering loop
      let onRenderFcts = [];

      // init scene and camera
      let scene = new THREE.Scene();

      //////////////////////////////////////////////////////////////////////////////////
      //		Initialize a basic camera
      //////////////////////////////////////////////////////////////////////////////////

      // Create a camera
      let camera = new THREE.Camera();
      scene.add(camera);

      ////////////////////////////////////////////////////////////////////////////////
      //          handle arToolkitSource
      ////////////////////////////////////////////////////////////////////////////////

      let arToolkitSource = new THREEx.ArToolkitSource({
        // type of source - ['webcam', 'image', 'video']
        sourceType: "webcam",

        // // to read from an image
        // sourceType : 'image',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',

        // to read from a video
        // sourceType : 'video',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',

        // // resolution of at which we initialize the source image
        sourceWidth: 960,
        sourceHeight: 720,
        // // resolution displayed for the source
        displayWidth: 960,
        displayHeight: 720,
      });

      arToolkitSource.init(function onReady() {
        setTimeout(() => {
          onResize();
        }, 250);
      });

      // handle resize
      window.addEventListener("resize", function () {
        onResize();
      });

      function onResize() {
        arToolkitSource.onResizeElement();
        arToolkitSource.copyElementSizeTo(renderer.domElement);
        if (arToolkitContext.arController !== null) {
          arToolkitSource.copyElementSizeTo(
            arToolkitContext.arController.canvas
          );
        }
      }
      ////////////////////////////////////////////////////////////////////////////////
      //          initialize arToolkitContext
      ////////////////////////////////////////////////////////////////////////////////

      // create atToolkitContext
      let arToolkitContext = new THREEx.ArToolkitContext({
        // debug - true if one should display artoolkit debug canvas, false otherwise
        debug: false,

        // the mode of detection - ['color', 'color_and_matrix', 'mono', 'mono_and_matrix']
        detectionMode: "mono",

        // type of matrix code - valid iif detectionMode end with 'matrix' - [3x3, 3x3_HAMMING63, 3x3_PARITY65, 4x4, 4x4_BCH_13_9_3, 4x4_BCH_13_5_5]
        // matrixCodeType: "3x3",

        // Pattern ratio for custom markers
        patternRatio: 0.5,

        // Labeling mode for markers - ['black_region', 'white_region']
        // black_region: Black bordered markers on a white background, white_region: White bordered markers on a black background
        // labelingMode: "black_region",

        // url of the camera parameters
        cameraParametersUrl:
          THREEx.ArToolkitContext.baseURL + "../data/data/camera_para.dat",

        // tune the maximum rate of pose detection in the source image
        // maxDetectionRate: 60,

        // resolution of at which we detect pose in the source image
        // canvasWidth: 640,
        // canvasHeight: 480,

        // enable image smoothing or not for canvas copy - default to true
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
        imageSmoothingEnabled: true,
      });

      // initialize it
      arToolkitContext.init(function onCompleted() {
        // copy projection matrix to camera
        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
      });

      // update artoolkit on every frame
      onRenderFcts.push(function () {
        if (arToolkitSource.ready === false) return;

        arToolkitContext.update(arToolkitSource.domElement);

        // update scene.visible if the marker is seen
        // scene.visible = camera.visible;
      });

      ////////////////////////////////////////////////////////////
      // setup markerRoots
      ////////////////////////////////////////////////////////////

      let markerRootArray = [];
      let markerGroupArray = [];
      let patternArray = [
        "letterA",
        "letterB",
        "letterC",
        "letterD",
        "letterF",
        "kanji",
      ];

      let positionScene = [
        new THREE.Vector3(0, 0, -0.75),
        new THREE.Vector3(-0.75, 0, 0),
        new THREE.Vector3(0, 0, 0.75),
        new THREE.Vector3(0.75, 0, 0),
        new THREE.Vector3(0, 0.75, 0),
        new THREE.Vector3(0, -0.75, 0),
      ];

      let rotationArray = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(
          THREE.Math.degToRad(-90),
          0,
          THREE.Math.degToRad(-90)
        ),
        new THREE.Vector3(THREE.Math.degToRad(180), 0, 0),
        new THREE.Vector3(THREE.Math.degToRad(-90), 0, THREE.Math.degToRad(90)),
        new THREE.Vector3(THREE.Math.degToRad(-90), 0, 0),
        new THREE.Vector3(
          THREE.Math.degToRad(-90),
          0,
          THREE.Math.degToRad(180)
        ),
      ];

      for (let i = 0; i < 6; i++) {
        let markerRoot = new THREE.Group();
        markerRootArray.push(markerRoot);
        scene.add(markerRoot);
        let markerControls = new THREEx.ArMarkerControls(
          arToolkitContext,
          markerRoot,
          {
            size: 1,
            type: "pattern",
            patternUrl: "../magic-cube/data/" + patternArray[i] + ".patt",
            // changeMatrixMode: "cameraTransformMatrix",
          }
        );

        let markerGroup = new THREE.Group();
        markerGroupArray.push(markerGroup);
        markerGroup.rotation.setFromVector3(rotationArray[i]);

        markerRoot.add(markerGroup);
      }

      // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
      // scene.visible = false;

      //////////////////////////////////////////////////////////////////////////////////
      //    add an object in the scene
      //////////////////////////////////////////////////////////////////////////////////
      // a simple cube
      let sceneGroup = new THREE.Group();
      let loader = new THREE.TextureLoader();

      let materialArray = [
        new THREE.MeshBasicMaterial({
          map: loader.load("../magic-cube/img/xpos.png"),
        }),
        new THREE.MeshBasicMaterial({
          map: loader.load("../magic-cube/img/xneg.png"),
        }),
        new THREE.MeshBasicMaterial({
          map: loader.load("../magic-cube/img/zpos.png"),
        }),
        new THREE.MeshBasicMaterial({
          map: loader.load("../magic-cube/img/zneg.png"),
        }),
        new THREE.MeshBasicMaterial({
          map: loader.load("../magic-cube/img/ypos.png"),
        }),
        new THREE.MeshBasicMaterial({
          map: loader.load("../magic-cube/img/yneg.png"),
        }),
      ];
      let mesh = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), materialArray);
      sceneGroup.add(mesh);

      // let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
      // scene.add(ambientLight);

      //
      onRenderFcts.push(function (delta) {
        // update artoolkit on every frame
        if (arToolkitSource.ready !== false)
          arToolkitContext.update(arToolkitSource.domElement);

        for (let i = 0; i < 6; i++) {
          if (markerRootArray[i].visible) {
            sceneGroup.position.copy(positionScene[i]);
            markerGroupArray[i].add(sceneGroup);
            console.log("visible: " + patternArray[i]);
            break;
          }
        }
      });

      //////////////////////////////////////////////////////////////////////////////////
      //		render the whole thing on the page
      //////////////////////////////////////////////////////////////////////////////////

      // render the scene
      onRenderFcts.push(function () {
        renderer.render(scene, camera);
      });

      // run the rendering loop
      let lastTimeMsec = null;
      requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        let deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        onRenderFcts.forEach(function (onRenderFct) {
          onRenderFct(deltaMsec / 1000, nowMsec / 1000);
        });
      });
    </script>
  </body>
</html>
